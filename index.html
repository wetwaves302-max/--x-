<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>正負數四則運算練習｜先加減後乘除（含括號）</title>
  <meta name="description" content="正負數加減乘除、先加減後乘除；含計分、音效、盲點診斷與錯題類題複習；手機友善；所有算式保留( )。">
  <style>
    :root{
      --bg:#fff8fb; --card:#ffffff; --primary:#ff88b3; --primary-2:#ffd4e4;
      --text:#333; --muted:#777; --good:#2e7d32; --bad:#c62828; --shadow:0 10px 25px rgba(255,136,179,0.15);
      --radius:18px;
    }
    *{box-sizing:border-box;}
    body{margin:0; font-family:ui-rounded,"Segoe UI",system-ui,-apple-system,"PingFang TC","Noto Sans TC",sans-serif;
      background:linear-gradient(180deg,var(--bg),#fff); color:var(--text);}
    header{position:sticky; top:0; z-index:10; background:linear-gradient(180deg,#fff,var(--bg));
      padding:10px 12px 6px; box-shadow:0 4px 12px rgba(0,0,0,0.04);}
    .wrap{max-width:960px; margin:0 auto; padding:14px;}
    .brand{display:flex; gap:10px; align-items:center; padding:8px 10px;}
    .brand .logo{width:40px; height:40px; border-radius:12px; background:var(--primary-2); display:grid; place-items:center; font-size:22px; box-shadow:var(--shadow);}
    .brand h1{margin:0; font-size:18px;}
    .brand p{margin:0; color:var(--muted); font-size:13px;}
    .bar{width:100%; height:10px; background:#f0f0f0; border-radius:999px; overflow:hidden; margin-top:10px;}
    .bar .fill{height:100%; width:0%; background:linear-gradient(90deg,var(--primary),#ffa1c5); transition:width .35s; border-radius:999px;}
    .stats{display:flex; flex-wrap:wrap; gap:10px; margin-top:8px; color:#444; font-size:13px;}
    .chip{background:#fff; padding:6px 10px; border-radius:999px; box-shadow:var(--shadow);}
    .grid{display:grid; gap:14px; grid-template-columns:1fr; margin-top:14px;}
    @media(min-width:900px){ .grid{grid-template-columns:260px 1fr;} }
    .card{background:var(--card); border-radius:var(--radius); box-shadow:var(--shadow); padding:14px;}
    .section-title{margin:0 0 8px; font-size:16px; font-weight:700;}
    .modes{display:flex; flex-wrap:wrap; gap:8px;}
    .mode-btn{border:none; border-radius:12px; padding:10px 12px; background:#fff; box-shadow:var(--shadow); font-size:14px; cursor:pointer;}
    .mode-btn.active{background:var(--primary); color:#fff;}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .problem{font-size:28px; font-weight:800; letter-spacing:.5px; padding:10px 14px; border-radius:14px;
      background:linear-gradient(180deg,#fff,#fff2f6); box-shadow:var(--shadow); display:flex; align-items:center; justify-content:center; min-height:72px;}
    .answer-area{display:grid; grid-template-columns:1fr; gap:10px;}
    .answer-input{width:100%; font-size:20px; padding:12px 14px; border-radius:12px; border:2px solid #eee; outline:none;}
    .answer-input:focus{border-color:var(--primary);}
    .keypad{display:grid; grid-template-columns:repeat(4,1fr); gap:8px;}
    .key{padding:12px 10px; border:none; border-radius:12px; background:#fff; box-shadow:var(--shadow); font-size:18px; cursor:pointer;}
    .key.primary{background:var(--primary); color:#fff;}
    .controls{display:flex; gap:8px; flex-wrap:wrap;}
    .btn{border:none; border-radius:12px; padding:10px 12px; background:#fff; box-shadow:var(--shadow); font-size:14px; cursor:pointer;}
    .btn.primary{background:var(--primary); color:#fff;}
    .feedback{border-left:6px solid var(--primary); background:#fff; padding:10px 12px; border-radius:12px; box-shadow:var(--shadow); line-height:1.6; font-size:15px;}
    .hint{color:#5c6bc0;} .muted{color:var(--muted); font-size:12px;}
    .footer{text-align:center; color:var(--muted); padding:16px 0 40px; font-size:12px;}
    .shake{animation:shake .3s linear;} @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-3px)}50%{transform:translateX(3px)}75%{transform:translateX(-2px)}100%{transform:translateX(0)}}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="brand">
        <div class="logo">🌸</div>
        <div>
          <h1>正負數四則運算練習（先加減，後乘除）</h1>
          <p>溫馨可愛・手機優先・含盲點診斷與類題複習 ✨（所有算式保留括號）</p>
        </div>
      </div>
      <div class="bar" aria-label="progress"><div id="progressFill" class="fill"></div></div>
      <div class="stats" id="stats">
        <span class="chip">題數：<b id="qCount">0</b></span>
        <span class="chip">正確：<b id="qCorrect">0</b></span>
        <span class="chip">正確率：<b id="qRate">0%</b></span>
        <span class="chip">分數：<b id="score">0</b></span>
        <span class="chip">連對：<b id="streak">0</b> 🔥</span>
        <span class="chip">模式：<b id="modeLabel">—</b></span>
      </div>
    </div>
  </header>

  <main class="wrap grid">
    <!-- 左：模式與設定 -->
    <section class="card">
      <h2 class="section-title">練習主題</h2>
      <div class="modes" id="modes"></div>
      <hr style="border:none;height:1px;background:#f2f2f2;margin:14px 0;">
      <h2 class="section-title">小設定</h2>
      <div class="row" style="gap:6px 10px">
        <span class="muted">題庫範圍：−20～20（除法避免 0、盡量整數）</span>
        <span class="muted">每題 +10 / 答錯 −5；所有數字與步驟以 ( ) 顯示</span>
      </div>
      <div class="row" style="margin-top:8px">
        <button class="btn" id="btnReset">重置統計</button>
        <button class="btn" id="btnReview" title="錯題複習（出同結構類題）">開始錯題複習</button>
        <span class="muted" id="reviewBadge">（目前錯題：0）</span>
      </div>
      <p class="muted" style="margin-top:8px">💡 本版採「先加減，後乘除」的特殊規則，題面會用括號清楚標示先算的加減群組。</p>
    </section>

    <!-- 右：作答區 -->
    <section class="card">
      <div class="row" style="justify-content:space-between; align-items:flex-start;">
        <div class="problem" id="problem">請先選擇一個練習主題 👈</div>
        <div class="row" style="gap:6px">
          <button class="btn" id="btnPrev" disabled>上一題</button>
          <button class="btn" id="btnNext" disabled>下一題</button>
        </div>
      </div>

      <div class="grid" style="grid-template-columns:1fr; margin-top:12px">
        <div class="answer-area">
          <input id="answer" class="answer-input" inputmode="numeric" placeholder="在這裡輸入答案（可用下方鍵盤）" />
          <div class="keypad" id="keypad"></div>
          <div class="controls">
            <button class="btn" id="btnSkip">略過</button>
            <button class="btn primary" id="btnSubmit">送出</button>
          </div>
          <div id="feedback" class="feedback" style="display:none"></div>
        </div>
      </div>
    </section>
  </main>

  <div class="footer">© 2025 正負數小宇宙 · 為學習加油 💗</div>

  <script>
    /***************
     * 可調整參數  *
     ***************/
    const SCORE_CORRECT = 10;
    const SCORE_WRONG = 5;
    const PROGRESS_TARGET = 20;

    /***************
     * 狀態管理     *
     ***************/
    const state = {
      mode: null,
      history: [], // {displayExpr, tokens, answer, user, correct, explain, structure}
      pointer: -1,
      score: 0,
      streak: 0,
      reviewQueue: [],
    };

    const Modes = [
      { id:'addsub', label:'① 正負數加減 ➕➖' },
      { id:'muldiv', label:'② 正負數乘除 ✖️➗' },
      { id:'mixed',  label:'③ 正負數四則混合 🔀（先加減後乘除）' },
      { id:'preced', label:'④ 先加減，後乘除 ⚖️' },
    ];

    /***************
     * 小工具       *
     ***************/
    const $ = sel => document.querySelector(sel);
    const elModes = $('#modes'), elProblem = $('#problem'), elAnswer = $('#answer'),
          elKeypad = $('#keypad'), elFeedback = $('#feedback'),
          elQCount = $('#qCount'), elQCorrect = $('#qCorrect'), elQRate = $('#qRate'),
          elScore = $('#score'), elStreak = $('#streak'), elModeLabel = $('#modeLabel'),
          elProgressFill = $('#progressFill'), elReviewBadge = $('#reviewBadge'),
          elBtnPrev = $('#btnPrev'), elBtnNext = $('#btnNext'), elBtnReset = $('#btnReset'),
          elBtnReview = $('#btnReview'), elBtnSkip = $('#btnSkip'), elBtnSubmit = $('#btnSubmit');

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
    function choice(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    const isAddSub = op => (op==='+'||op==='-');
    const isMulDiv = op => (op==='×'||op==='÷');

    // 格式化：所有數字都放在 ( ) 內，貼近紙筆
    function showNum(n){ return `(${n})`; }

    // 音效
    function playTone(ok=true){
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type = ok ? 'sine' : 'square'; o.frequency.value = ok ? 880 : 220;
      o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.001, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.01);
      o.start(); const dur = ok ? 0.12 : 0.18;
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
      o.stop(ctx.currentTime+dur+0.01);
    }

    function updateStats(){
      const total = state.history.length;
      const correct = state.history.filter(h=>h.correct).length;
      const rate = total? Math.round(correct*100/total):0;
      elQCount.textContent = total; elQCorrect.textContent = correct; elQRate.textContent = rate + '%';
      elScore.textContent = state.score; elStreak.textContent = state.streak;
      elProgressFill.style.width = Math.min(100, Math.round((total/PROGRESS_TARGET)*100)) + '%';
      elReviewBadge.textContent = `（目前錯題：${state.reviewQueue.length}）`;
      elModeLabel.textContent = state.mode ? Modes.find(m=>m.id===state.mode).label : '—';
      localStorage.setItem('int_arith_state_prefsADMD', JSON.stringify(state, (k,v)=> k==='history' ? v.slice(-200) : v));
    }
    (function loadPersist(){
      try{ const s = JSON.parse(localStorage.getItem('int_arith_state_prefsADMD')||'null'); if(s){ Object.assign(state, s); updateStats(); } }catch(e){}
    })();

    /***********************
     * 自訂運算評分邏輯     *
     * 規則：先加減，後乘除 *
     ***********************/
    // tokens 形式： [number, op, number, op, number]，op in ['+','-','×','÷']
    function evalWithAddFirst(tokens){
      // 第一段：先把 + / - 由左到右做完，留下乘除待後
      // 例：a + b × c - d → ((a + b) × c) - d，但我們第一段只合併加減：a' × c - d
      let arr = tokens.slice();
      // 合併所有加減
      for(let i=1; i<arr.length-1; ){
        const op = arr[i];
        if(isAddSub(op)){
          const left = arr[i-1], right = arr[i+1];
          const val = (op==='+') ? (left + right) : (left - right);
          // 替換成一個數字
          arr.splice(i-1, 3, val);
          // i 回到上一個位置繼續檢查
          i = Math.max(1, i-2);
        }else{
          i += 2;
        }
      }
      // 第二段：剩下只會有乘除，從左到右
      let result = arr[0];
      for(let i=1; i<arr.length; i+=2){
        const op = arr[i], right = arr[i+1];
        if(op==='×') result = result * right;
        else if(op==='÷'){
          if(right===0) return NaN;
          result = result / right;
        }
      }
      return result;
    }

    function buildDisplayFromTokens(tokens){
      // 依規則加上括號：先把所有「加減群組」加括號
      // 三數兩運算的情況，容易辨識：
      if(tokens.length===5){
        const [a,op1,b,op2,c] = tokens;
        // 若存在加減與乘除混合，將加減群組括起來
        if(isAddSub(op1) && isMulDiv(op2)){
          // (a ± b) ×/÷ c
          return `(${showNum(a)} ${op1} ${showNum(b)}) ${op2} ${showNum(c)}`;
        }
        if(isMulDiv(op1) && isAddSub(op2)){
          // a ×/÷ (b ± c)
          return `${showNum(a)} ${op1} (${showNum(b)} ${op2} ${showNum(c)})`;
        }
        // 同類型（都加減 或 都乘除）：仍用 ( ) 包住每個數，維持一致視覺
        return `${showNum(a)} ${op1} ${showNum(b)} ${op2} ${showNum(c)}`;
      }
      // 二元
      if(tokens.length===3){
        const [a,op,b] = tokens;
        return `${showNum(a)} ${op} ${showNum(b)}`;
      }
      // Fallback：逐段
      return tokens.map(t => (typeof t==='number' ? showNum(t) : t)).join(' ');
    }

    function recordFromTokens(tokens, structure){
      // 反覆嘗試直到答案為整數（避免小數干擾）
      let ans = evalWithAddFirst(tokens);
      let tries = 0;
      while((!Number.isFinite(ans) || !Number.isInteger(ans)) && tries<20){
        // 簡單回退：重新生成同結構的新數字
        tokens = regenSameShape(tokens);
        ans = evalWithAddFirst(tokens);
        tries++;
      }
      const displayExpr = buildDisplayFromTokens(tokens);
      return {displayExpr, tokens, answer: ans, user:null, correct:null, explain:null, structure};
    }

    function regenSameShape(tokens){
      // 保持運算子不變，換數字（維持正/負傾向）
      const newT = tokens.slice();
      for(let i=0;i<newT.length;i+=2){
        const old = newT[i];
        let n = randInt(-12,12);
        if(old!==0) n = Math.abs(n)*Math.sign(old);
        if(i>0 && newT[i-1]==='÷' && n===0) n = choice([-3,-2,-1,1,2,3]);
        newT[i] = n;
      }
      return newT;
    }

    /*****************
     * 題目產生器     *
     *****************/
    function genAddSub(){
      const a = randInt(-20,20), b = randInt(-20,20);
      const op = choice(['+','-']);
      return recordFromTokens([a,op,b], {kind:'bin',op,a,b,rule:'add-first'});
    }

    function genMulDiv(){
      let a = randInt(-12,12), b = randInt(-12,12);
      if(b===0) b = choice([-3,-2,-1,1,2,3]);
      const op = choice(['×','÷']);
      if(op==='÷'){ a = (randInt(-10,10)||1)*b; } // 讓結果多半為整數
      return recordFromTokens([a,op,b], {kind:'bin',op,a,b,rule:'add-first'});
    }

    function genMixed(){
      // 兩步運算，確保有「加減」與「乘除」共同出現，才能練到規則
      // 模式 A: (a ± b) ×/÷ c
      // 模式 B: a ×/÷ (b ± c)
      const pattern = choice(['A','B']);
      if(pattern==='A'){
        let a = randInt(-12,12), b = randInt(-12,12), c = randInt(-12,12);
        const op1 = choice(['+','-']); let op2 = choice(['×','÷']);
        if(op2==='÷'){ if(c===0) c = choice([-3,-2,-1,1,2,3]); }
        return recordFromTokens([a,op1,b,op2,c], {kind:'tri',shape:'(a±b)op c',op1,op2,a,b,c,rule:'add-first'});
      }else{
        let a = randInt(-12,12), b = randInt(-12,12), c = randInt(-12,12);
        const op1 = choice(['×','÷']); let op2 = choice(['+','-']);
        if(op1==='÷'){ if(b===0) b = choice([-3,-2,-1,1,2,3]); a = (randInt(-8,8)||1)*b; }
        return recordFromTokens([a,op1,b,op2,c], {kind:'tri',shape:'a op (b±c)',op1,op2,a,b,c,rule:'add-first'});
      }
    }

    function genPrecedence(){ // 專練「先加減，後乘除」
      // 盡量生成一定含一個加減與一個乘除
      return genMixed();
    }

    function genQuestion(){
      if(state.mode==='addsub') return genAddSub();
      if(state.mode==='muldiv') return genMulDiv();
      if(state.mode==='mixed')  return genMixed();
      if(state.mode==='preced') return genPrecedence();
      return null;
    }

    /*****************
     * 盲點診斷       *
     *****************/
    function diagnose(struct, correctAns, userAns){
      const tips = [];
      if(struct.kind==='bin'){
        if(struct.op==='+' || struct.op==='-'){
          tips.push('加減：同號相加保符號；異號先比大小再相減，取較大數的符號。把負數都寫成 (−3) 這種樣子更清楚。');
        }else{
          tips.push('乘除前，先把符號規則想清楚：同號得正、異號得負；再算數值。');
        }
      }else{
        tips.push('本題規則是「先加減，後乘除」。請把要先算的加減部分用括號括起來，例如：(a + b) × c 或 a ÷ (b − c)。');
        tips.push('步驟建議：① 先算括號裡的加減；② 再做乘除；③ 最後檢查符號。');
      }
      if(Number.isFinite(userAns) && Number.isFinite(correctAns) && Math.abs(userAns - correctAns)===1){
        tips.push('你的答案只差 1，可能是最後一步抄寫或加減時的小失誤，重算最後兩步。');
      }
      tips.push('小撇步：所有負數與中間結果都用括號（如 (−4)、((−4)+7)），能大幅降低看錯號。');
      return tips;
    }

    /*****************
     * 類題產生       *
     *****************/
    function similarQuestion(struct){
      // 依原結構出新數字
      if(struct.kind==='bin'){
        let a = randInt(-12,12), b = randInt(-12,12);
        if(struct.op==='÷'){ if(b===0) b = choice([-3,-2,-1,1,2,3]); a = (randInt(-8,8)||1)*b; }
        return recordFromTokens([a,struct.op,b], struct);
      }
      if(struct.kind==='tri'){
        if(struct.shape==='(a±b)op c'){
          let a = randInt(-12,12), b = randInt(-12,12), c = randInt(-12,12);
          if(struct.op2==='÷'){ if(c===0) c = choice([-3,-2,-1,1,2,3]); }
          return recordFromTokens([a,struct.op1,b,struct.op2,c], struct);
        }else{ // a op (b±c)
          let a = randInt(-12,12), b = randInt(-12,12), c = randInt(-12,12);
          if(struct.op1==='÷'){ if(b===0) b = choice([-3,-2,-1,1,2,3]); a = (randInt(-8,8)||1)*b; }
          return recordFromTokens([a,struct.op1,b,struct.op2,c], struct);
        }
      }
      // fallback
      const q = genQuestion();
      return q;
    }

    /*****************
     * 呈現與互動     *
     *****************/
    function setProblem(text){ elProblem.textContent = text; }
    function setFeedback(html, good=false, show=true){
      if(!show){ elFeedback.style.display='none'; return; }
      elFeedback.innerHTML = html; elFeedback.style.display = 'block';
      if(!good){ elFeedback.classList.add('shake'); setTimeout(()=>elFeedback.classList.remove('shake'),300); }
    }
    function pushHistory(item){ state.history.push(item); state.pointer = state.history.length-1; }
    function showCurrent(){
      const h = state.history[state.pointer]; if(!h) return;
      setProblem(h.displayExpr); elAnswer.value=''; setFeedback('',false,false);
      elBtnPrev.disabled = (state.pointer<=0); elBtnNext.disabled = (state.pointer>=state.history.length-1);
    }
    function newQuestion(){
      if(!state.mode) return;
      const q = genQuestion();
      setProblem(q.displayExpr); elAnswer.value=''; setFeedback('',false,false);
      pushHistory(q); elBtnPrev.disabled = (state.pointer<=0); elBtnNext.disabled = true; updateStats();
    }
    function startReview(){
      if(state.reviewQueue.length===0){ setFeedback('目前沒有錯題可以複習，先做幾題再回來吧 🌱', true, true); return; }
      const struct = state.reviewQueue.shift();
      const sim = similarQuestion(struct);
      setProblem(sim.displayExpr + '（類題）'); elAnswer.value='';
      setFeedback('<span class="hint">這題依你的錯誤類型出「類題」。先按規則把要先算的加減圈起來再算！</span>', true, true);
      pushHistory(sim); updateStats(); elBtnPrev.disabled=(state.pointer<=0); elBtnNext.disabled=true;
    }

    function submit(){
      const h = state.history[state.pointer]; if(!h) return;
      const raw = elAnswer.value.trim(); if(!raw){ elAnswer.focus(); return; }
      const user = Number(raw); const correct = (user===h.answer);
      h.user = user; h.correct = correct;

      if(correct){
        playTone(true); state.score += SCORE_CORRECT; state.streak += 1;
        setFeedback(`✅ <b>答對了！</b> ${h.displayExpr} = <b>${h.answer}</b><br><span class="muted">太棒了～繼續保持！</span>`, true, true);
      }else{
        playTone(false); state.score -= SCORE_WRONG; state.streak = 0;
        const tips = diagnose(h.structure||{kind:'tri'}, h.answer, user); h.explain = tips.join('<br>');
        if(h.structure) state.reviewQueue.push(h.structure);
        setFeedback(`❌ <b>可惜！</b> 正確答案是 <b>${h.answer}</b><br><br><b>盲點診斷：</b><br>${tips.map(t=>'• '+t).join('<br>')}<br><br><span class="hint">👉 點「開始錯題複習」出同結構類題！</span>`, false, true);
      }
      elBtnNext.disabled = false; updateStats();
    }

    /*****************
     * 事件綁定       *
     *****************/
    // 模式按鈕
    (function buildModeButtons(){
      Modes.forEach(m=>{
        const b=document.createElement('button'); b.className='mode-btn'; b.textContent=m.label;
        b.addEventListener('click',()=>{
          document.querySelectorAll('.mode-btn').forEach(x=>x.classList.remove('active'));
          b.classList.add('active'); state.mode=m.id; state.streak=0;
          setFeedback('已切換模式，開始新一題吧！', true, true); newQuestion(); updateStats();
        });
        elModes.appendChild(b);
      });
    })();

    // 數字鍵盤（含負號）
    (function buildKeypad(){
      ['7','8','9','⌫','4','5','6','清除','1','2','3','−','0','00','±','送出'].forEach(k=>{
        const btn=document.createElement('button'); btn.className='key'+(k==='送出'?' primary':''); btn.textContent=k;
        btn.addEventListener('click',()=>{
          if(k==='送出') return submit();
          if(k==='清除'){ elAnswer.value=''; return; }
          if(k==='⌫'){ elAnswer.value = elAnswer.value.slice(0,-1); return; }
          if(k==='−'){ if(!elAnswer.value.startsWith('-')) elAnswer.value='-'+elAnswer.value; return; }
          if(k==='±'){ elAnswer.value = elAnswer.value.startsWith('-') ? elAnswer.value.slice(1) : (elAnswer.value?('-'+elAnswer.value):'-'); return; }
          elAnswer.value += k;
        });
        elKeypad.appendChild(btn);
      });
    })();

    elBtnSubmit.addEventListener('click', submit);
    elBtnSkip.addEventListener('click', newQuestion);
    elBtnPrev.addEventListener('click', ()=>{ if(state.pointer>0){ state.pointer--; showCurrent(); } });
    elBtnNext.addEventListener('click', ()=>{ if(state.pointer<state.history.length-1){ state.pointer++; showCurrent(); } else { newQuestion(); } });
    elBtnReset.addEventListener('click', ()=>{
      if(confirm('確定要重置統計與進度嗎？')){
        state.history=[]; state.pointer=-1; state.score=0; state.streak=0; state.reviewQueue=[];
        setProblem('已重置，請選擇主題或按「下一題」開始。'); setFeedback('',false,false); updateStats();
        elBtnPrev.disabled=true; elBtnNext.disabled=true;
      }
    });
    elBtnReview.addEventListener('click', startReview);
    elAnswer.addEventListener('keydown', e=>{ if(e.key==='Enter') submit(); });

    // 初始化提示
    if(!state.mode){
      setFeedback('請先在左側選擇一個練習主題（例如「③ 四則混合」或「④ 先加減，後乘除」），再開始作答。', true, true);
    }
  </script>
</body>
</html>
